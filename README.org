#+Title: PiSnort: A Delayed Alarm System for Raspberry Pi
#+Author: Sean Allred
#+Date: [2014-01-09 Thu]

#+PROPERTY: noweb tangle

* Introduction and Overview
  :PROPERTIES:
  :ID:       323E5699-2136-4258-AD30-2AD3361F4FA7
  :END:
#+BEGIN_SRC python :tangle "main.py" :shebang "#!/usr/bin/sudo python"
  import gpioutil as gu
  import RPi.GPIO as gpio
  import subprocess               # For playing sound files
  import random                   # For randomizing sound files
  import time                     # To delay sound playing
  import logging

  <<setup logging>>
  
  <<sound-playing logic>>
  
  if __name__ == '__main__':
      log = logging.getLogger('root')
      log.info('Execution started.')
  
      print 'Welcome to PiSnort!'
      play_sound('system/welcome.wav')
  
      <<define state>>
  
      <<define pins>>
  
      <<define sounds>>
    
      log.info('Beginning main loop.')
      try:
          while True:
              <<run loop>>
      except KeyboardInterrupt:
          log.info('Process ended with C-c C-c.')
          print '\n\nCaught SIGINT'
      finally:
          print 'Exiting.'
          log.info('Cleaning up GPIO...')
          gpio.cleanup()
          log.info('Cleaning up GPIO... Done.')
#+END_SRC

* The Meat
:PROPERTIES:
:noweb-ref: play a random sound file
:END:
Choose a random sound file to play and then wait ten seconds.  Play
the file, then wait another five minutes to avoid a double alarm.
#+BEGIN_SRC python
  <<choose a random sound file to play>>
  log.info('Waiting ten seconds to play sound.')
  time.sleep(10)

  play_sound(soundfile)

  log.info('Waiting five minutes to continue execution')
  time.sleep(600)
#+END_SRC

** Choosing a Random Sound to Play
:PROPERTIES:
:noweb-ref: choose a random sound file to play
:END:
#+BEGIN_SRC python
  choices = [key for key in snorts if bool(snorts[key][0])]
  soundfile = random.choice(choices)
#+END_SRC

** TODO Implement lambda filtering of recordings
I seem to remember a requirement being the ability to play /certain/
sounds.  I'm not sure of the details of this requirement, but lambdas
can be used here (using the =[i for i in [...] if f(i)]= construction).

* Define and Initialize Pins
:PROPERTIES:
:noweb-ref: define pins
:END:
These are all of the pins used in the circuitry.  Explicit ground
wires are not listed; if something is missing, just complete the
circuit.  Refer to the Fritzing diagram if you're unsure.
#+BEGIN_SRC python
  gpio.setmode(gpio.BCM)
  
  pins = {
      'LED power':    gu.Pin(4,           gpio.OUT, gpio.LOW),
      'PIR power':    gu.Pin(gu.Pin.VOLT, gpio.OUT, gpio.HIGH),
      'Button power': gu.Pin(gu.Pin.VOLT, gpio.OUT, gpio.HIGH),
      'PIR Signal':   gu.Pin(2,           gpio.IN),
      'Button in':    gu.Pin(8,           gpio.IN),
      'Button out':   gu.Pin(7,           gpio.IN)
    }
  
  gu.setup_all(pins)
#+END_SRC

* Define Recording Locations
:PROPERTIES:
:noweb-ref: define sounds
:END:
Trusted sources say these are mixed squirrel and deer sounds.  They
should be organized as such.  This is not something I am trained to do
(and I neither recorded nor named these files), so I'm waiting on the
project manager to do this. They all sound like bloody murdur to me.
#+BEGIN_SRC python
  snorts = {'record2snort2.wav':     ('some criterion'),
            'record3snort1.wav':     ('some criterion'),
            'record3snort2.wav':     ('some criterion'),
            'record4snort1.wav':     ('some criterion'),
            'record4snort2.wav':     ('some criterion'),
            'recorded snort1-3.wav': ('some criterion'),
            'recorded snort1.wav':   ('some criterion'),
            'recorded snort2.wav':   ('some criterion')}
#+END_SRC

The actual sound files aren't included in the project as they are
decently large and won't benefit from version control.

* The Main Loop
:PROPERTIES:
:noweb-ref: run loop
:END:
#+BEGIN_SRC python
  log.debug('Executing loop')
#+END_SRC

First, we need to update the internal state so we know we have current
information.  This will intelligently update properties such as
=button_depressed= and =motion_detected= so we can use them later.
#+BEGIN_SRC python
  <<update state>>
#+END_SRC

If the button is depressed, we want to toggle the state of the device.
Press once and the device should turn on.  Press once more and the
device should turn off.
#+BEGIN_SRC python
  if state.button_depressed:
      <<toggle state>>
#+END_SRC
It should be noted that the device won't /actually/ turn off; it will
merely stop looking for motion.

When testing a new wiring, it's good to just get a few tests of the
LEDs and the speakers in.  (I'll probably be adding more tests later,
but that's beside the point.)  If we are not testing, then check to
see if we've detected motion.  If we have, choose a random sound file
to play and then play it.
#+BEGIN_SRC python
  if state.testing:
      <<testing logic>>
      state.testing = False
  elif state.on and state.motion_detected:
      <<play a random sound file>>
#+END_SRC

** Testing Logic
:PROPERTIES:
:noweb-ref: testing logic
:END:
Toggle the LED ten times, waiting a second between each.
#+BEGIN_SRC python
  for i in range(10):
      print 'Toggling LED on pin {}'.format(pins['LED power'].number)
      gu.toggle(pins['LED power'])
      time.sleep(1)
  print 'Diagnostic complete.'
  play_sound('system/diagnostic.wav')
#+END_SRC
* Playing a Sound
:PROPERTIES:
:noweb-ref: sound-playing logic
:END:
Actually playing the sound is a pretty simple matter.  Don't forget to
ensure that your speaker is hooked up to the Pi over 3.5mm.

#+BEGIN_SRC python
  def play_sound(relative_path):
      log = logging.getLogger('sounds')
      log.info('Playing sound: %s', relative_path)
      subprocess.call(['aplay',  'sounds/{!s}'.format(relative_path)])
#+END_SRC

* Keeping State
:PROPERTIES:
:noweb-ref: define state
:END:
#+BEGIN_SRC python 
  class State: pass
  state=State()
  state.testing = True
  state.on = False
  state.led_on = True
  state.button_depressed = False
  state.motion_detected = False
#+END_SRC

* Reading a New State
:PROPERTIES:
:noweb-ref: update state
:END:
#+BEGIN_SRC python
  log.debug('Updating state...')
#+END_SRC

Check for changes in button state.  This logic should allow the system
to manage a toggle on/off button for the system state using the
momentary latch provided by the button.
#+BEGIN_SRC python
  if gu.read_pin(pins['Button in']):
      if not state.button_depressed:
          log.debug('Caught button state change.')
          state.button_depressed = True
  else:
      state.button_depressed = False
#+END_SRC

Check for any input from the PIR.  If motion is detected, set the
appropriate flag.  (This can easily be collapsed to one line, but is
expanded here for clarity.)
#+BEGIN_SRC python
  if gu.read_pin(pins['PIR Signal']):
      log.info('Motion detected!')
      state.motion_detected = True
  else:
      state.motion_detected = False
#+END_SRC

#+BEGIN_SRC python
  log.debug('Updating state... Done.')
#+END_SRC

* On/Off System Toggling
:PROPERTIES:
:noweb-ref: toggle state
:END:
#+BEGIN_SRC python
  log.debug('Toggling state...')
    
  if state.on:
      log.debug('Turning LED OFF')
      gu.set_pin(pins['LED power'], gpio.LOW)
      play_sound('system/deactivate.wav')
  else:
      log.debug('Turning LED ON')
      gu.set_pin(pins['LED power'], gpio.HIGH)
      play_sound('system/activate.wav')
    
  state.on = not state.on
  log.debug('Toggling state... Done.')
#+END_SRC

* Logging
:PROPERTIES:
:noweb-ref: setup logging
:ID:       D29AE728-7504-4E9D-86F5-A9E0AB16DBDC
:END:
#+BEGIN_SRC python
  import logging.config
  logging.config.fileConfig('logging.conf')
#+END_SRC

#+BEGIN_SRC conf :tangle "logging.conf" :noweb-ref nil
  [loggers]
  keys=root,sounds
  
  [handlers]
  keys=consoleHandler
  
  [formatters]
  keys=simpleFormatter
  
  [logger_root]
  level=DEBUG
  handlers=consoleHandler
  
  [logger_sounds]
  level=DEBUG
  handlers=consoleHandler
  qualname=sounds
  propagate=0
  
  [handler_consoleHandler]
  class=StreamHandler
  level=DEBUG
  formatter=simpleFormatter
  args=(sys.stdout,)
  
  [formatter_simpleFormatter]
  format=%(asctime)s (%(name)s) - %(levelname)s: %(message)s
#+END_SRC
* Appendix
** GPIO Utility Functions
:PROPERTIES:
:tangle:   gpioutil.py
:END:
*** Dependencies
:PROPERTIES:
:ID:       E1A00A15-8596-4767-B7D6-8ACEB374375A
:END:
#+BEGIN_SRC python
  import RPi.GPIO
  <<setup logging>>
#+END_SRC
*** Define =Pin= Class
:PROPERTIES:
:ID:       8EF060AB-774C-445F-93DC-563694D980E4
:END:
#+BEGIN_SRC python
  class Pin:
      VOLT = 1
      GROUND = 0
      def __init__(self, number, mode, state=None):
          self.number = number
          self.mode = mode
          self.state = state
      def __int__(self):
          return self.number
#+END_SRC
*** Writing Pins
:PROPERTIES:
:ID:       458363F0-81F2-4B12-9854-5961696987E4
:END:
#+BEGIN_SRC python
  def set_pin(pin, state):
      assert pin.mode is RPi.GPIO.OUT
      pin.state = state
      RPi.GPIO.output(pin.number, pin.state)
#+END_SRC
*** Reading Pins
:PROPERTIES:
:ID:       5FC5B406-9D0C-42B5-9CAF-62269A27D491
:END:
#+BEGIN_SRC python
  def read_pin(pin):
      assert pin.mode is RPi.GPIO.IN
  
      return RPi.GPIO.input(pin.number)
#+END_SRC
*** Toggling Pins
:PROPERTIES:
:ID:       51113440-033A-4CA7-9AC1-3C6EA282AE23
:END:
#+BEGIN_SRC python
  def toggle(pin):
      assert pin.mode is RPi.GPIO.OUT
      if pin.state is RPi.GPIO.HIGH:
          set_pin(pin, RPi.GPIO.LOW)
      elif pin.state is RPi.GPIO.LOW:
          set_pin(pin, RPi.GPIO.HIGH)
      else:
          raise Exception('What happened?  Pin {} is neither HIGH nor LOW.'.format(pin))
#+END_SRC
*** Setup Loop
:PROPERTIES:
:ID:       C4EB5B4E-2CA6-4860-B2CF-8BA91964FF95
:END:
#+BEGIN_SRC python
  def setup_all(pins):
      for pin in pins.values():
          if pin.number in [Pin.VOLT, Pin.GROUND]:
              continue
  
          assert pin.mode in [RPi.GPIO.IN, RPi.GPIO.OUT]
          assert pin.state in [RPi.GPIO.HIGH, RPi.GPIO.LOW, None]
          if pin.mode is RPi.GPIO.IN:
              assert pin.state is None
  
          print 'Running initial setup...'
          print '\tPin {} is {}'.format(pin.number, 'IN' if pin.mode is RPi.GPIO.IN else 'OUT')
          RPi.GPIO.setup(pin.number, pin.mode)
          if pin.mode is RPi.GPIO.OUT:
              print '\t\tSetting to {}'.format('HIGH' if pin.state is RPi.GPIO.HIGH else 'LOW')
              RPi.GPIO.output(pin.number, pin.state)
#+END_SRC
